<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HAIRKEY /// VOID WALKER</title>
    
    <!-- FONTS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=JetBrains+Mono:wght@400;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- CLOUDFLARE -->
    <script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer></script>

    <style>
        /* =========================================
           1. CORE VARIABLES & RESET
           ========================================= */
        :root {
            --bg-void: #030305;
            --panel-bg: rgba(10, 12, 16, 0.85);
            --neon-cyan: #00f3ff;
            --neon-purple: #bc13fe;
            --neon-green: #00ff9d;
            --neon-red: #ff003c;
            --border-dim: rgba(0, 243, 255, 0.15);
            --font-head: 'Audiowide', sans-serif;
            --font-code: 'JetBrains Mono', monospace;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        
        body {
            background-color: var(--bg-void);
            color: var(--neon-cyan);
            font-family: var(--font-code);
            height: 100vh; overflow: hidden;
            display: flex; justify-content: center; align-items: center;
            /* 3D removed per request */
        }

        /* =========================================
           2. BACKGROUND FX
           ========================================= */
        #void-network {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0; opacity: 0.2;
        }

        .scanlines {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 3px, 3px 100%;
            z-index: 2; pointer-events: none;
        }

        .vignette {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 40%, #000 100%);
            z-index: 1; pointer-events: none;
        }

        /* =========================================
           3. MAIN INTERFACE (FLAT & SHARP)
           ========================================= */
        .void-card {
            width: 520px;
            background: var(--panel-bg);
            border: 1px solid var(--border-dim);
            position: relative; z-index: 10;
            backdrop-filter: blur(15px);
            box-shadow: 0 0 60px rgba(0, 0, 0, 0.8);
            /* Tech Corners Shape */
            clip-path: polygon(
                20px 0, 100% 0, 
                100% calc(100% - 20px), calc(100% - 20px) 100%, 
                0 100%, 0 20px
            );
            padding: 2px; /* Border container */
        }

        /* Animated Glowing Border */
        .void-card::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, var(--neon-cyan), transparent 40%, transparent 60%, var(--neon-purple));
            z-index: -1; opacity: 0.5;
        }

        .inner-content {
            background: #080a0e;
            padding: 35px;
            clip-path: polygon(
                20px 0, 100% 0, 
                100% calc(100% - 20px), calc(100% - 20px) 100%, 
                0 100%, 0 20px
            );
            min-height: 400px;
            display: flex; flex-direction: column;
        }

        /* =========================================
           4. UI COMPONENTS
           ========================================= */
        /* Header */
        .header-section {
            border-bottom: 1px solid var(--border-dim);
            padding-bottom: 15px; margin-bottom: 20px;
            display: flex; justify-content: space-between; align-items: flex-end;
        }
        h1 { 
            font-family: var(--font-head); font-size: 2rem; 
            letter-spacing: 2px; color: #fff; margin: 0;
            text-shadow: 0 0 10px var(--neon-cyan);
        }
        .version { font-size: 0.7rem; color: #666; letter-spacing: 1px; }
        
        .sys-status { display: flex; gap: 5px; align-items: center; font-size: 0.65rem; color: var(--neon-green); }
        .blink-dot { width: 6px; height: 6px; background: var(--neon-green); border-radius: 50%; animation: blink 1s infinite; }

        /* Terminal Logs */
        .console-box {
            background: #020202;
            border: 1px solid #222;
            height: 100px; padding: 10px;
            overflow: hidden;
            font-size: 0.7rem; color: #888;
            margin-bottom: 25px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8);
        }
        .log-entry { margin-bottom: 4px; display: flex; }
        .log-time { color: #444; margin-right: 8px; }
        .log-msg { color: #aaa; }
        .c-warn { color: var(--neon-purple); }
        .c-err { color: var(--neon-red); }
        .c-succ { color: var(--neon-green); }

        /* Action Zone */
        .action-zone { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; }

        /* Status Badge */
        .status-display {
            font-family: var(--font-head);
            font-size: 0.9rem; letter-spacing: 2px;
            padding: 8px 20px; border: 1px solid var(--neon-cyan);
            background: rgba(0, 243, 255, 0.05);
            margin-bottom: 20px;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.1);
        }

        /* Buttons */
        .void-btn {
            width: 100%; max-width: 300px;
            padding: 16px; background: transparent;
            border: 1px solid var(--neon-cyan);
            color: var(--neon-cyan);
            font-family: var(--font-head); letter-spacing: 2px;
            cursor: pointer; transition: 0.3s;
            position: relative; overflow: hidden;
        }
        .void-btn::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
            background: var(--neon-cyan); transition: 0.3s; z-index: -1;
        }
        .void-btn:hover { color: #000; box-shadow: 0 0 20px var(--neon-cyan); }
        .void-btn:hover::before { left: 0; }
        .void-btn:disabled { border-color: #444; color: #444; cursor: not-allowed; box-shadow: none; }
        .void-btn:disabled::before { display: none; }

        /* Key Vault */
        .key-container {
            width: 100%; text-align: center;
            background: rgba(0, 255, 157, 0.03);
            border: 1px dashed var(--neon-green);
            padding: 25px; cursor: pointer;
            position: relative;
            transition: 0.3s;
        }
        .key-container:hover { background: rgba(0, 255, 157, 0.08); border-style: solid; }
        
        .key-text {
            font-size: 1.6rem; color: var(--neon-green);
            text-shadow: 0 0 8px rgba(0, 255, 157, 0.6);
            word-break: break-all; font-weight: bold;
        }
        
        /* Time Duration */
        .time-box {
            margin-top: 15px; font-size: 0.8rem;
            display: flex; align-items: center; justify-content: center; gap: 8px;
            color: #ccc;
        }
        .time-val { color: var(--neon-cyan); font-weight: bold; font-size: 1rem; }

        /* Turnstile */
        #turnstile-wrapper { min-height: 65px; margin-bottom: 15px; display: flex; justify-content: center; }

        /* Animations */
        .hidden { display: none !important; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

    </style>
</head>
<body>

    <canvas id="void-network"></canvas>
    <div class="scanlines"></div>
    <div class="vignette"></div>

    <div class="void-card">
        <div class="inner-content">
            
            <!-- HEADER -->
            <div class="header-section">
                <div>
                    <h1>HAIRKEY</h1>
                    <div class="version">VOID WALKER PROTOCOL // v6.0</div>
                </div>
                <div class="sys-status">
                    <div class="blink-dot"></div> NET_ONLINE
                </div>
            </div>

            <!-- LOGS -->
            <div class="console-box" id="console">
                <!-- Logs will be injected here -->
            </div>

            <!-- MAIN ACTION -->
            <div class="action-zone">
                
                <!-- STATE: CHECKPOINT -->
                <div id="view-checkpoint" style="width: 100%; text-align: center;">
                    <div id="status-badge" class="status-display">SECURITY CHECK REQUIRED</div>
                    
                    <div id="turnstile-wrapper"></div>

                    <button id="btn-main" class="void-btn" onclick="handleAction()" disabled>
                        <i class="fas fa-shield-alt"></i> INITIALIZE
                    </button>
                </div>

                <!-- STATE: SUCCESS -->
                <div id="view-success" class="hidden" style="width: 100%;">
                    <div class="status-display" style="border-color: var(--neon-green); color: var(--neon-green); width: 100%; text-align: center;">
                        <i class="fas fa-check-circle"></i> ACCESS GRANTED
                    </div>

                    <div class="key-container" onclick="copyKey()">
                        <div id="key-output" class="key-text">LOADING...</div>
                        <div style="font-size: 0.6rem; color: #666; margin-top: 5px; letter-spacing: 2px;">CLICK TO COPY</div>
                    </div>

                    <div class="time-box">
                        <i class="far fa-clock"></i> SESSION EXPIRES IN: 
                        <span id="timer-val" class="time-val">--:--:--</span>
                    </div>
                </div>

            </div>

        </div>
    </div>

    <script>
        // ==========================================
        // CONFIGURATION
        // ==========================================
        const CONFIG = {
            CLOUDFLARE_SITE_KEY: "0x4AAAAAABBLlduN6HavujOQ", 
            API: {
                PROFILE: '/api/profile',
                START: '/api/start-process',
                VERIFY: '/api/verify-step',
                COMPLETE: '/api/complete-process'
            }
        };

        // GLOBAL STATE
        let STATE = {
            sessionId: null,
            cfToken: null,
            currentStep: 0,
            totalSteps: 1
        };

        // ==========================================
        // INITIALIZATION
        // ==========================================
        window.onload = async () => {
            initBackground(); // Void Network FX
            logSystem("KERNEL", "Initializing HairKey Interface v6.0...");
            
            const urlParams = new URLSearchParams(window.location.search);
            STATE.sessionId = urlParams.get('id');
            const verifyToken = urlParams.get('verify_token');

            // 1. HANDLE VERIFY RETURN
            if (verifyToken) {
                logSystem("NET", "Verify token detected. Validating...");
                setLoading(true, "VERIFYING STEP...");
                
                try {
                    const res = await fetch(CONFIG.API.VERIFY, {
                        method: 'POST', headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ sessionId: STATE.sessionId, token: verifyToken })
                    });
                    const data = await res.json();
                    
                    if (data.success) {
                        logSystem("SEC", "Step verified successfully.", "succ");
                        window.history.replaceState({}, document.title, `/?id=${STATE.sessionId}`);
                    } else {
                        logSystem("ERR", "Token rejected: " + data.error, "err");
                        setStatus("VERIFICATION FAILED", "var(--neon-red)");
                    }
                } catch(e) { logSystem("ERR", "Connection failure during verify", "err"); }
                
                setLoading(false);
            }

            // 2. LOAD PROFILE
            if (STATE.sessionId) {
                await loadProfile();
            } else {
                logSystem("FATAL", "Missing Session ID.", "err");
                document.querySelector('.action-zone').innerHTML = `<h3 style="color:var(--neon-red)">LINK EXPIRED OR INVALID</h3>`;
            }
        };

        // ==========================================
        // CORE LOGIC
        // ==========================================
        async function loadProfile() {
            logSystem("NET", "Fetching user profile...");
            try {
                const res = await fetch(CONFIG.API.PROFILE, {
                    method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ sessionId: STATE.sessionId })
                });
                const data = await res.json();

                if (data.success) {
                    logSystem("AUTH", `User Identified: ${data.hwidShort}`, "succ");
                    STATE.currentStep = data.currentStep || 0;
                    STATE.totalSteps = data.totalSteps || 1;

                    if (data.keyStatus === "ACTIVE") {
                        showSuccess(data.currentKey, data.timeLeft);
                    } else {
                        if (STATE.currentStep >= STATE.totalSteps) {
                            logSystem("SYS", "All steps cleared. Requesting key...", "succ");
                            await checkCompletion();
                        } else {
                            setupCheckpoint();
                        }
                    }
                } else {
                    await checkCompletion(); // Last ditch attempt
                }
            } catch (e) { logSystem("ERR", "Failed to load profile", "err"); }
        }

        function setupCheckpoint() {
            const displayStep = STATE.currentStep + 1;
            const total = STATE.totalSteps;
            const btn = document.getElementById('btn-main');
            
            setStatus(total > 1 ? `CHECKPOINT ${displayStep} / ${total}` : "SECURITY CHECK", "var(--neon-cyan)");
            logSystem("SYS", `Initiating Checkpoint ${displayStep}...`);

            // Reset Button
            btn.innerHTML = `<i class="fas fa-lock"></i> AWAITING CAPTCHA`;
            btn.disabled = true;

            // Render Cloudflare
            document.getElementById('turnstile-wrapper').innerHTML = "";
            turnstile.render('#turnstile-wrapper', {
                sitekey: CONFIG.CLOUDFLARE_SITE_KEY,
                theme: 'dark',
                callback: function(token) {
                    STATE.cfToken = token;
                    btn.disabled = false;
                    btn.innerHTML = `<i class="fas fa-bolt"></i> CONTINUE`;
                    btn.style.borderColor = "var(--neon-green)";
                    btn.style.color = "var(--neon-green)";
                    logSystem("SEC", "Human verification passed.", "succ");
                }
            });
        }

        async function handleAction() {
            if(!STATE.cfToken) return;
            setLoading(true, "GENERATING LINK...");
            
            try {
                const res = await fetch(CONFIG.API.START, {
                    method: 'POST', headers: {'Content-Type': 'application/json'}, 
                    body: JSON.stringify({ sessionId: STATE.sessionId, cfToken: STATE.cfToken })
                });
                const data = await res.json();
                
                if(data.success) {
                    logSystem("NET", "Link generated. Redirecting...", "warn");
                    window.location.href = data.link; 
                } else {
                    logSystem("ERR", data.error, "err");
                    setStatus("ERROR: " + data.error, "var(--neon-red)");
                    setTimeout(() => window.location.reload(), 2000);
                }
            } catch(e) {
                logSystem("ERR", "Network Error", "err");
                setLoading(false);
            }
        }

        async function checkCompletion() {
            const res = await fetch(CONFIG.API.COMPLETE, {
                method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ sessionId: STATE.sessionId })
            });
            const data = await res.json();
            
            if(data.success) {
                // Key generated fresh, assume 24h or get from server logic if possible
                // Since this API usually returns key, we assume standard expiry. 
                // Better to reload profile to get exact time, but here we can estimate.
                showSuccess(data.key, 86400); 
            } else {
                if (data.refresh) {
                    window.location.reload();
                } else {
                    logSystem("ERR", "Session invalid. Please restart script.", "err");
                    setStatus("SESSION EXPIRED", "var(--neon-red)");
                }
            }
        }

        function showSuccess(key, timeLeft) {
            document.getElementById('view-checkpoint').classList.add('hidden');
            document.getElementById('view-success').classList.remove('hidden');
            
            // Text Scramble Effect for Key
            const el = document.getElementById('key-output');
            let iterations = 0;
            const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
            const interval = setInterval(() => {
                el.innerText = key.split("").map((letter, index) => {
                    if(index < iterations) return key[index];
                    return chars[Math.floor(Math.random() * chars.length)];
                }).join("");
                if(iterations >= key.length) clearInterval(interval);
                iterations += 1/2;
            }, 30);

            logSystem("CRYPTO", "Key decrypted successfully.", "succ");
            startTimer(timeLeft);
        }

        function startTimer(seconds) {
            const timerEl = document.getElementById('timer-val');
            
            function update() {
                if (seconds <= 0) {
                    timerEl.innerText = "EXPIRED";
                    timerEl.style.color = "var(--neon-red)";
                    return;
                }
                seconds--;
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                const s = seconds % 60;
                timerEl.innerText = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
            }
            update();
            setInterval(update, 1000);
        }

        function copyKey() {
            const k = document.getElementById('key-output').innerText;
            navigator.clipboard.writeText(k);
            logSystem("SYS", "Key copied to clipboard.", "succ");
            alert("COPIED!");
        }

        // ==========================================
        // UTILS & FX
        // ==========================================
        function logSystem(module, msg, type="info") {
            const box = document.getElementById('console');
            const time = new Date().toLocaleTimeString('en-GB');
            const colorClass = type === 'err' ? 'c-err' : (type === 'succ' ? 'c-succ' : (type === 'warn' ? 'c-warn' : ''));
            
            const html = `
                <div class="log-entry">
                    <span class="log-time">[${time}]</span>
                    <span class="log-module">[${module}]</span>&nbsp;
                    <span class="log-msg ${colorClass}">${msg}</span>
                </div>`;
            
            box.insertAdjacentHTML('beforeend', html);
            box.scrollTop = box.scrollHeight;
        }

        function setStatus(text, color) {
            const badge = document.getElementById('status-badge');
            badge.innerText = text;
            badge.style.color = color;
            badge.style.borderColor = color;
            badge.style.boxShadow = `0 0 15px ${color}33`;
        }

        function setLoading(isLoading, text) {
            const btn = document.getElementById('btn-main');
            if(isLoading) {
                btn.innerHTML = `<i class="fas fa-circle-notch fa-spin"></i> ${text}`;
                btn.disabled = true;
                btn.style.color = "var(--neon-purple)";
                btn.style.borderColor = "var(--neon-purple)";
            }
        }

        // Background Animation (Void Network)
        function initBackground() {
            const canvas = document.getElementById('void-network');
            const ctx = canvas.getContext('2d');
            let w, h, particles = [];

            function resize() { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; }
            window.addEventListener('resize', resize); resize();

            for(let i=0; i<50; i++) particles.push({
                x: Math.random()*w, y: Math.random()*h,
                vx: (Math.random()-0.5)*0.5, vy: (Math.random()-0.5)*0.5
            });

            function animate() {
                ctx.clearRect(0,0,w,h);
                ctx.fillStyle = '#00f3ff';
                
                particles.forEach((p, i) => {
                    p.x += p.vx; p.y += p.vy;
                    if(p.x<0 || p.x>w) p.vx*=-1; if(p.y<0 || p.y>h) p.vy*=-1;
                    
                    ctx.beginPath(); ctx.arc(p.x, p.y, 1.5, 0, Math.PI*2); ctx.fill();
                    
                    particles.slice(i+1).forEach(p2 => {
                        const d = Math.hypot(p.x-p2.x, p.y-p2.y);
                        if(d<150) {
                            ctx.beginPath(); 
                            ctx.strokeStyle = `rgba(0, 243, 255, ${1 - d/150})`; 
                            ctx.lineWidth = 0.5;
                            ctx.moveTo(p.x, p.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                        }
                    });
                });
                requestAnimationFrame(animate);
            }
            animate();
        }
    </script>
</body>
</html>